# Module 9.3: Real-Time Inference Fundamentals

## Overview

Real-time inference enables machine learning models to make predictions on streaming data with minimal latency. In semiconductor manufacturing, this capability is critical for:

- **Online defect detection**: Analyzing wafer images as they're captured
- **Process control**: Adjusting parameters based on sensor readings
- **Equipment health monitoring**: Detecting anomalies in real-time
- **Yield prediction**: Making instant forecasts as fabrication progresses

This module covers streaming data processing, asynchronous deployment patterns, and production-ready real-time inference systems.

---

## Learning Objectives

By the end of this module, you will be able to:

1. **Understand streaming data architectures** for real-time ML
2. **Implement async inference endpoints** with FastAPI
3. **Process sensor streams** with configurable batch sizes
4. **Handle backpressure** and flow control in production systems
5. **Monitor real-time inference performance** (latency, throughput)
6. **Deploy scalable streaming pipelines** for manufacturing environments

---

## Fundamentals of Real-Time Inference

### Batch vs Streaming Inference

**Batch Inference**:
- Process large datasets at scheduled intervals
- Optimized for throughput
- Acceptable latency: minutes to hours
- Use case: Daily yield reports, weekly quality analysis

**Streaming Inference**:
- Process data as it arrives
- Optimized for latency
- Acceptable latency: milliseconds to seconds
- Use case: Live defect detection, process control

**Micro-Batch Inference**:
- Hybrid approach: small batches processed continuously
- Balances latency and throughput
- Acceptable latency: seconds
- Use case: Near real-time monitoring with some buffering

### Key Concepts

#### 1. Latency Requirements

Manufacturing real-time inference latency targets:

| Application | Target Latency | Tolerance | Example |
|-------------|---------------|-----------|---------|
| **Emergency shutdown** | < 100ms | Critical | Equipment safety |
| **Process control** | < 1s | High | Parameter adjustment |
| **Defect detection** | < 5s | Medium | Wafer inspection |
| **Yield forecasting** | < 30s | Low | Fab optimization |

#### 2. Throughput Requirements

Data rates in semiconductor manufacturing:

- **High-speed cameras**: 100-1000 images/second
- **Sensor arrays**: 1000-10000 readings/second
- **Equipment logs**: 100-1000 events/second
- **Metrology tools**: 10-100 measurements/second

#### 3. Backpressure Management

When data arrives faster than it can be processed:

**Strategies**:
1. **Buffering**: Queue incoming data (risk: memory overflow)
2. **Sampling**: Process subset of data (risk: miss anomalies)
3. **Load shedding**: Drop oldest/newest data (risk: data loss)
4. **Auto-scaling**: Add inference workers (cost: infrastructure)

---

## Streaming Data Architectures

### Architecture Patterns

#### Pattern 1: Direct HTTP Streaming

```
Sensor → HTTP POST → FastAPI → Model → Response
```

**Pros**:
- Simple to implement
- No additional infrastructure
- Good for low-volume streams

**Cons**:
- Limited scalability
- No built-in buffering
- Single point of failure

#### Pattern 2: Message Queue

```
Sensor → Kafka/RabbitMQ → Consumer → Model → Results Topic
```

**Pros**:
- Decouples producers/consumers
- Built-in buffering
- Horizontal scalability
- Replay capability

**Cons**:
- Additional infrastructure
- More complex setup
- Eventual consistency

#### Pattern 3: Streaming Platform

```
Sensor → Kafka Streams → Model (KServe) → Output Stream
```

**Pros**:
- Enterprise-grade scalability
- Fault tolerance
- Exactly-once processing
- Complex event processing

**Cons**:
- High complexity
- Significant infrastructure
- Steeper learning curve

### This Module's Approach

We implement **Pattern 1 (Direct HTTP Streaming)** with async FastAPI because it:
- Requires minimal infrastructure
- Teaches core async concepts
- Suitable for learning and prototyping
- Can be extended to Patterns 2 & 3

---

## Asynchronous Programming for ML

### Why Async Matters

**Synchronous (Blocking)**:
```python
def predict(data):
    # Blocks thread while model runs
    result = model.predict(data)
    return result

# Can only handle 1 request at a time per thread
```

**Asynchronous (Non-Blocking)**:
```python
async def predict(data):
    # Releases thread while waiting for I/O
    result = await asyncio.get_event_loop().run_in_executor(
        None, model.predict, data
    )
    return result

# Can handle multiple requests concurrently
```

### When to Use Async

**Use Async When**:
- I/O-bound operations (network, disk, database)
- Multiple concurrent requests
- Streaming data sources
- Websocket connections

**Avoid Async When**:
- CPU-bound ML inference (better: thread pool, GPU batching)
- Simple batch processing
- Single-request workloads

### FastAPI Async Patterns

#### Pattern 1: Async Endpoint (I/O-bound)

```python
from fastapi import FastAPI
import asyncio

app = FastAPI()

@app.post("/predict-async")
async def predict_async(data: dict):
    # Good for I/O: database queries, API calls
    result = await fetch_from_database(data["id"])
    return result
```

#### Pattern 2: Sync Endpoint with Async Server (CPU-bound)

```python
@app.post("/predict")
def predict(data: dict):
    # Sync endpoint, but FastAPI runs on async server
    # Good for CPU-bound ML inference
    result = model.predict(data["features"])
    return result
```

#### Pattern 3: Background Tasks

```python
from fastapi import BackgroundTasks

@app.post("/predict-background")
def predict_background(data: dict, background_tasks: BackgroundTasks):
    background_tasks.add_task(log_prediction, data)
    result = model.predict(data["features"])
    return result
```

---

## Real-Time Inference Pipeline Components

### 1. Streaming Data Source

**Sensor Data Stream Simulator**:
```python
class SensorStreamSimulator:
    def __init__(self, rate_hz: float = 10.0):
        self.rate_hz = rate_hz
        self.interval = 1.0 / rate_hz

    async def generate_stream(self):
        while True:
            # Simulate sensor reading
            reading = {
                "timestamp": datetime.now().isoformat(),
                "temperature": np.random.normal(350, 5),
                "pressure": np.random.normal(1013, 10),
                "flow_rate": np.random.normal(100, 2)
            }
            yield reading
            await asyncio.sleep(self.interval)
```

### 2. Inference Engine

**Model Wrapper for Streaming**:
```python
class StreamingInferenceEngine:
    def __init__(self, model_path: str, batch_size: int = 32):
        self.model = joblib.load(model_path)
        self.batch_size = batch_size
        self.buffer = []

    async def predict_single(self, data: dict) -> dict:
        """Single prediction (low latency)"""
        features = self.extract_features(data)
        prediction = self.model.predict([features])[0]
        return {"prediction": prediction, "timestamp": datetime.now()}

    async def predict_batch(self, data_list: list) -> list:
        """Batch prediction (higher throughput)"""
        features = [self.extract_features(d) for d in data_list]
        predictions = self.model.predict(features)
        return [{"prediction": p} for p in predictions]
```

### 3. Result Handling

**Result Storage and Alerting**:
```python
class ResultHandler:
    def __init__(self, alert_threshold: float = 0.9):
        self.alert_threshold = alert_threshold

    async def handle_result(self, result: dict):
        # Store result
        await self.store_result(result)

        # Check for alerts
        if result.get("anomaly_score", 0) > self.alert_threshold:
            await self.send_alert(result)

    async def store_result(self, result: dict):
        # In production: write to time-series DB (InfluxDB, TimescaleDB)
        pass

    async def send_alert(self, result: dict):
        # In production: send to alerting system (PagerDuty, Slack)
        pass
```

---

## FastAPI Streaming Endpoints

### Endpoint 1: Single Prediction (REST)

```python
from fastapi import FastAPI
from pydantic import BaseModel

class PredictionRequest(BaseModel):
    timestamp: str
    temperature: float
    pressure: float
    flow_rate: float

@app.post("/predict")
def predict(request: PredictionRequest):
    features = [request.temperature, request.pressure, request.flow_rate]
    prediction = model.predict([features])[0]
    return {
        "prediction": float(prediction),
        "timestamp": request.timestamp,
        "latency_ms": 15.2  # measured
    }
```

### Endpoint 2: Batch Prediction (REST)

```python
@app.post("/predict-batch")
def predict_batch(requests: list[PredictionRequest]):
    features = [
        [r.temperature, r.pressure, r.flow_rate]
        for r in requests
    ]
    predictions = model.predict(features)
    return {
        "predictions": [float(p) for p in predictions],
        "count": len(predictions),
        "avg_latency_ms": 2.1  # per prediction
    }
```

### Endpoint 3: Server-Sent Events (SSE)

```python
from fastapi.responses import StreamingResponse
import asyncio

@app.get("/stream-predictions")
async def stream_predictions():
    async def generate():
        sensor_stream = SensorStreamSimulator(rate_hz=1.0)
        async for reading in sensor_stream.generate_stream():
            prediction = model.predict([[
                reading["temperature"],
                reading["pressure"],
                reading["flow_rate"]
            ]])[0]

            yield f"data: {json.dumps({'reading': reading, 'prediction': float(prediction)})}\n\n"

    return StreamingResponse(generate(), media_type="text/event-stream")
```

### Endpoint 4: WebSocket (Bidirectional)

```python
from fastapi import WebSocket

@app.websocket("/ws/predict")
async def websocket_predict(websocket: WebSocket):
    await websocket.accept()
    try:
        while True:
            # Receive sensor data
            data = await websocket.receive_json()

            # Make prediction
            features = [data["temperature"], data["pressure"], data["flow_rate"]]
            prediction = model.predict([features])[0]

            # Send result back
            await websocket.send_json({
                "prediction": float(prediction),
                "timestamp": datetime.now().isoformat()
            })
    except Exception as e:
        await websocket.close()
```

---

## Performance Optimization

### 1. Model Optimization

**Reduce Inference Latency**:

```python
# Option 1: Model Quantization
from sklearn.ensemble import RandomForestClassifier
import numpy as np

# Use fewer trees for faster inference
fast_model = RandomForestClassifier(n_estimators=10)  # vs 100

# Option 2: Feature Reduction
from sklearn.decomposition import PCA

pca = PCA(n_components=10)  # Reduce 100 features to 10
X_reduced = pca.fit_transform(X)

# Option 3: Simpler Model
from sklearn.linear_model import LogisticRegression

# LR is 10-100x faster than RF for similar tasks
fast_model = LogisticRegression()
```

**Batch Inference for Throughput**:

```python
class BatchingInferenceEngine:
    def __init__(self, model, max_batch_size=32, max_wait_ms=100):
        self.model = model
        self.max_batch_size = max_batch_size
        self.max_wait_ms = max_wait_ms
        self.queue = asyncio.Queue()

    async def predict(self, features):
        # Add to queue
        future = asyncio.Future()
        await self.queue.put((features, future))
        return await future

    async def batch_processor(self):
        while True:
            batch = []
            futures = []
            deadline = time.time() + self.max_wait_ms / 1000

            # Collect batch
            while len(batch) < self.max_batch_size:
                timeout = max(0, deadline - time.time())
                try:
                    features, future = await asyncio.wait_for(
                        self.queue.get(), timeout=timeout
                    )
                    batch.append(features)
                    futures.append(future)
                except asyncio.TimeoutError:
                    break

            if batch:
                # Batch inference
                predictions = self.model.predict(batch)
                for future, pred in zip(futures, predictions):
                    future.set_result(pred)
```

### 2. Caching

**Result Caching for Repeated Inputs**:

```python
from functools import lru_cache
import hashlib

class CachedInferenceEngine:
    def __init__(self, model, cache_size=1000):
        self.model = model
        self.cache = {}
        self.cache_size = cache_size

    def _hash_input(self, features):
        # Hash features for cache key
        return hashlib.md5(str(features).encode()).hexdigest()

    def predict(self, features):
        key = self._hash_input(features)

        # Check cache
        if key in self.cache:
            return self.cache[key]

        # Cache miss: run inference
        result = self.model.predict([features])[0]

        # Update cache (with LRU eviction)
        if len(self.cache) >= self.cache_size:
            # Remove oldest entry
            oldest_key = next(iter(self.cache))
            del self.cache[oldest_key]

        self.cache[key] = result
        return result
```

### 3. Concurrent Workers

**Thread Pool for CPU-Bound Inference**:

```python
from concurrent.futures import ThreadPoolExecutor
import asyncio

class ThreadedInferenceEngine:
    def __init__(self, model, max_workers=4):
        self.model = model
        self.executor = ThreadPoolExecutor(max_workers=max_workers)

    async def predict_async(self, features):
        loop = asyncio.get_event_loop()
        # Run CPU-bound inference in thread pool
        result = await loop.run_in_executor(
            self.executor,
            self.model.predict,
            [features]
        )
        return result[0]
```

---

## Monitoring Real-Time Inference

### Key Metrics

#### 1. Latency Metrics

```python
import time
from collections import deque

class LatencyMonitor:
    def __init__(self, window_size=100):
        self.latencies = deque(maxlen=window_size)

    def record_latency(self, latency_ms: float):
        self.latencies.append(latency_ms)

    def get_stats(self) -> dict:
        if not self.latencies:
            return {}

        latencies = list(self.latencies)
        return {
            "p50_ms": np.percentile(latencies, 50),
            "p95_ms": np.percentile(latencies, 95),
            "p99_ms": np.percentile(latencies, 99),
            "avg_ms": np.mean(latencies),
            "max_ms": np.max(latencies)
        }
```

#### 2. Throughput Metrics

```python
class ThroughputMonitor:
    def __init__(self, window_seconds=60):
        self.window_seconds = window_seconds
        self.timestamps = deque()

    def record_request(self):
        now = time.time()
        self.timestamps.append(now)

        # Remove old timestamps
        cutoff = now - self.window_seconds
        while self.timestamps and self.timestamps[0] < cutoff:
            self.timestamps.popleft()

    def get_throughput(self) -> float:
        """Requests per second"""
        if len(self.timestamps) < 2:
            return 0.0

        duration = self.timestamps[-1] - self.timestamps[0]
        if duration == 0:
            return 0.0

        return len(self.timestamps) / duration
```

#### 3. Error Rate Metrics

```python
class ErrorRateMonitor:
    def __init__(self, window_size=100):
        self.results = deque(maxlen=window_size)

    def record_result(self, success: bool):
        self.results.append(success)

    def get_error_rate(self) -> float:
        if not self.results:
            return 0.0

        errors = sum(1 for r in self.results if not r)
        return errors / len(self.results)
```

### Monitoring Dashboard Endpoint

```python
from fastapi import FastAPI

latency_monitor = LatencyMonitor()
throughput_monitor = ThroughputMonitor()
error_monitor = ErrorRateMonitor()

@app.get("/metrics")
def get_metrics():
    return {
        "latency": latency_monitor.get_stats(),
        "throughput_rps": throughput_monitor.get_throughput(),
        "error_rate": error_monitor.get_error_rate(),
        "timestamp": datetime.now().isoformat()
    }
```

---

## Production Deployment Patterns

### Pattern 1: Single FastAPI Instance

**Use Case**: Low volume (< 100 requests/second)

```bash
# Run with Uvicorn
uvicorn main:app --host 0.0.0.0 --port 8000 --workers 1

# Or with Gunicorn + Uvicorn workers
gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000
```

**Pros**: Simple, minimal resources  
**Cons**: Limited scalability, single point of failure

### Pattern 2: Load-Balanced FastAPI Cluster

**Use Case**: Medium volume (100-1000 requests/second)

```yaml
# docker-compose.yml
version: '3.8'
services:
  api-1:
    image: inference-api:latest
    ports:
      - "8001:8000"

  api-2:
    image: inference-api:latest
    ports:
      - "8002:8000"

  api-3:
    image: inference-api:latest
    ports:
      - "8003:8000"

  nginx:
    image: nginx:latest
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
```

**Pros**: Horizontal scaling, fault tolerance  
**Cons**: More complex, requires load balancer

### Pattern 3: Kubernetes + Auto-Scaling

**Use Case**: High volume (> 1000 requests/second), variable load

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: inference-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: inference-api
  template:
    metadata:
      labels:
        app: inference-api
    spec:
      containers:
      - name: api
        image: inference-api:latest
        resources:
          requests:
            cpu: "500m"
            memory: "512Mi"
          limits:
            cpu: "1000m"
            memory: "1Gi"
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: inference-api-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: inference-api
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

**Pros**: Auto-scaling, enterprise-grade  
**Cons**: Complex setup, higher costs

---

## Webcam Integration Example

### Real-Time Defect Detection

```python
import cv2
import numpy as np
from fastapi import FastAPI, WebSocket

app = FastAPI()

# Load defect detection model
model = joblib.load("models/defect_detector.joblib")

@app.websocket("/ws/webcam")
async def webcam_inference(websocket: WebSocket):
    await websocket.accept()

    try:
        while True:
            # Receive frame from webcam (base64 encoded)
            data = await websocket.receive_json()
            frame_b64 = data["frame"]

            # Decode frame
            frame_bytes = base64.b64decode(frame_b64)
            frame = cv2.imdecode(
                np.frombuffer(frame_bytes, np.uint8),
                cv2.IMREAD_COLOR
            )

            # Preprocess
            frame_resized = cv2.resize(frame, (224, 224))
            frame_normalized = frame_resized / 255.0

            # Inference
            prediction = model.predict([frame_normalized.flatten()])[0]

            # Send result
            await websocket.send_json({
                "defect_detected": bool(prediction),
                "confidence": 0.95,  # model.predict_proba if available
                "timestamp": datetime.now().isoformat()
            })

    except Exception as e:
        print(f"WebSocket error: {e}")
        await websocket.close()
```

**Client-Side (JavaScript)**:

```javascript
// Connect to webcam
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ws = new WebSocket('ws://localhost:8000/ws/webcam');

navigator.mediaDevices.getUserMedia({ video: true })
    .then(stream => video.srcObject = stream);

// Send frames to server
setInterval(() => {
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0, 224, 224);

    canvas.toBlob(blob => {
        const reader = new FileReader();
        reader.onload = () => {
            const base64 = reader.result.split(',')[1];
            ws.send(JSON.stringify({ frame: base64 }));
        };
        reader.readAsDataURL(blob);
    }, 'image/jpeg', 0.8);
}, 100);  // 10 FPS

// Receive predictions
ws.onmessage = (event) => {
    const result = JSON.parse(event.data);
    document.getElementById('result').textContent =
        result.defect_detected ? '🔴 DEFECT DETECTED' : '✅ OK';
};
```

---

## Semiconductor Use Cases

### Use Case 1: Real-Time Wafer Defect Detection

**Scenario**: Inspection tool captures 100 wafer images per second

**Requirements**:
- Latency: < 50ms per image
- Throughput: 100 images/second
- Accuracy: > 95% defect detection

**Solution**:
```python
# Batch inference with GPU acceleration
class WaferDefectDetector:
    def __init__(self, batch_size=16):
        self.model = load_cnn_model()  # GPU model
        self.batch_size = batch_size
        self.buffer = []

    async def detect(self, wafer_image):
        self.buffer.append(wafer_image)

        if len(self.buffer) >= self.batch_size:
            # Batch inference on GPU
            results = self.model.predict(np.array(self.buffer))
            self.buffer.clear()
            return results
```

### Use Case 2: Equipment Sensor Monitoring

**Scenario**: 1000 sensors reporting every second

**Requirements**:
- Latency: < 1s (anomaly detection)
- Throughput: 1000 readings/second
- Alerting: < 5s from anomaly to notification

**Solution**:
```python
class SensorAnomalyDetector:
    def __init__(self):
        self.model = load_isolation_forest()
        self.alert_queue = asyncio.Queue()

    async def monitor_stream(self, sensor_stream):
        async for reading in sensor_stream:
            # Quick inference
            is_anomaly = self.model.predict([reading])[0] == -1

            if is_anomaly:
                await self.alert_queue.put({
                    "sensor_id": reading["id"],
                    "value": reading["value"],
                    "timestamp": reading["timestamp"]
                })

    async def alert_handler(self):
        while True:
            alert = await self.alert_queue.get()
            await send_alert_to_ops(alert)  # PagerDuty, Slack, etc.
```

### Use Case 3: Process Parameter Optimization

**Scenario**: Continuous process with adjustable parameters

**Requirements**:
- Latency: < 5s (parameter adjustment)
- Optimization: Maximize yield in real-time
- Constraints: Safe operating ranges

**Solution**:
```python
class ProcessOptimizer:
    def __init__(self):
        self.yield_model = load_yield_predictor()
        self.current_params = get_default_params()

    async def optimize_continuously(self):
        while True:
            # Measure current yield
            current_yield = await get_current_yield()

            # Try small parameter adjustments
            candidates = self.generate_candidates(self.current_params)

            # Predict yield for each candidate
            predicted_yields = self.yield_model.predict(candidates)

            # Select best safe candidate
            best_idx = np.argmax(predicted_yields)
            new_params = candidates[best_idx]

            # Apply if better and safe
            if self.is_safe(new_params):
                await apply_parameters(new_params)
                self.current_params = new_params

            await asyncio.sleep(5)  # Adjust every 5 seconds
```

---

## Best Practices

### 1. Design for Failure

```python
class ResilientInferenceEngine:
    def __init__(self, model_path, fallback_model_path=None):
        self.model = joblib.load(model_path)
        self.fallback_model = None
        if fallback_model_path:
            self.fallback_model = joblib.load(fallback_model_path)

    async def predict(self, features):
        try:
            return self.model.predict([features])[0]
        except Exception as e:
            logging.error(f"Primary model failed: {e}")

            if self.fallback_model:
                try:
                    return self.fallback_model.predict([features])[0]
                except Exception as e2:
                    logging.error(f"Fallback model failed: {e2}")

            # Return safe default
            return self.get_safe_default()
```

### 2. Implement Circuit Breaker

```python
from enum import Enum
import time

class CircuitState(Enum):
    CLOSED = "closed"  # Normal operation
    OPEN = "open"      # Failing, reject requests
    HALF_OPEN = "half_open"  # Testing if recovered

class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout_seconds=60):
        self.failure_threshold = failure_threshold
        self.timeout_seconds = timeout_seconds
        self.state = CircuitState.CLOSED
        self.failures = 0
        self.last_failure_time = None

    def call(self, func, *args, **kwargs):
        if self.state == CircuitState.OPEN:
            if time.time() - self.last_failure_time > self.timeout_seconds:
                self.state = CircuitState.HALF_OPEN
            else:
                raise Exception("Circuit breaker is OPEN")

        try:
            result = func(*args, **kwargs)
            self.on_success()
            return result
        except Exception as e:
            self.on_failure()
            raise e

    def on_success(self):
        self.failures = 0
        self.state = CircuitState.CLOSED

    def on_failure(self):
        self.failures += 1
        self.last_failure_time = time.time()

        if self.failures >= self.failure_threshold:
            self.state = CircuitState.OPEN
```

### 3. Rate Limiting

```python
from fastapi import HTTPException
import time

class RateLimiter:
    def __init__(self, max_requests_per_minute=100):
        self.max_requests = max_requests_per_minute
        self.requests = {}  # {client_id: [timestamps]}

    def check_rate_limit(self, client_id: str):
        now = time.time()

        # Initialize or clean old requests
        if client_id not in self.requests:
            self.requests[client_id] = []

        self.requests[client_id] = [
            t for t in self.requests[client_id]
            if now - t < 60
        ]

        # Check limit
        if len(self.requests[client_id]) >= self.max_requests:
            raise HTTPException(
                status_code=429,
                detail="Rate limit exceeded"
            )

        self.requests[client_id].append(now)

# Usage
rate_limiter = RateLimiter(max_requests_per_minute=100)

@app.post("/predict")
def predict(request: PredictionRequest, client_id: str = Header(...)):
    rate_limiter.check_rate_limit(client_id)
    # ... inference logic
```

---

## Summary

Real-time inference enables semiconductor manufacturing systems to:
- Detect defects as they occur
- Optimize processes continuously
- Monitor equipment health proactively
- Respond to anomalies instantly

**Key Takeaways**:

1. **Choose the right architecture** for your latency and throughput requirements
2. **Use async patterns** for I/O-bound operations, thread pools for CPU-bound
3. **Implement monitoring** for latency, throughput, and error rates
4. **Design for failure** with circuit breakers, fallbacks, and safe defaults
5. **Optimize models** for inference speed without sacrificing accuracy
6. **Scale horizontally** with load balancing and auto-scaling

**Next Steps**:
- Implement the real-time inference pipeline script
- Deploy a streaming API with FastAPI
- Test with simulated sensor data
- Monitor performance under load
- Extend to production with Kubernetes or message queues

---

## Further Reading

**Books**:
- "Designing Data-Intensive Applications" by Martin Kleppmann
- "Building Microservices" by Sam Newman
- "Streaming Systems" by Tyler Akidau et al.

**Documentation**:
- FastAPI: https://fastapi.tiangolo.com/
- Uvicorn: https://www.uvicorn.org/
- AsyncIO: https://docs.python.org/3/library/asyncio.html

**Papers**:
- "Serving DNNs in Real Time at Datacenter Scale with Project Brainwave" (Microsoft Research)
- "Clipper: A Low-Latency Online Prediction Serving System" (UC Berkeley)

**Tools**:
- Locust (load testing): https://locust.io/
- Prometheus (monitoring): https://prometheus.io/
- Grafana (dashboards): https://grafana.com/
