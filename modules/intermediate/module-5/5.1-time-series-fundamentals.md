# Module 5.1 – Time Series Analysis for Semiconductor Manufacturing

## 1. Introduction

Time series analysis is crucial in semiconductor manufacturing for monitoring tool performance, predicting equipment failures, and forecasting key performance indicators (KPIs). This module focuses on ARIMA (AutoRegressive Integrated Moving Average) models and their seasonal variants for modeling temporal dependencies in manufacturing data.

## 2. Core Concepts

### 2.1 Time Series Components

Manufacturing time series typically exhibit multiple components:

- **Trend**: Long-term changes (e.g., tool wear, process drift)
- **Seasonality**: Repeating patterns (e.g., daily temperature cycles, weekly maintenance schedules)
- **Cyclical**: Longer irregular fluctuations (e.g., product mix changes)
- **Noise**: Random variations due to measurement uncertainty and process variability

### 2.2 Stationarity

A time series is stationary if its statistical properties (mean, variance, autocorrelation) remain constant over time. Most forecasting methods require stationary data.

**Augmented Dickey-Fuller (ADF) Test**: Tests the null hypothesis that the series has a unit root (non-stationary).
- H₀: Series is non-stationary (has unit root)
- H₁: Series is stationary
- If p-value < 0.05, reject H₀ (series is stationary)

**Achieving Stationarity**:
1. **Differencing**: Δy_t = y_t - y_{t-1}
2. **Log transformation**: For variance stabilization
3. **Seasonal differencing**: Δ_s y_t = y_t - y_{t-s}

### 2.3 ARIMA Models

ARIMA(p,d,q) models combine three components:

- **AR(p)**: AutoRegressive terms, captures dependency on past values
  ```
  y_t = φ₁y_{t-1} + φ₂y_{t-2} + ... + φₚy_{t-p} + ε_t
  ```

- **I(d)**: Integrated (differencing) to achieve stationarity
  ```
  (1-L)^d y_t = stationary_series
  ```

- **MA(q)**: Moving Average terms, captures dependency on past errors
  ```
  y_t = θ₁ε_{t-1} + θ₂ε_{t-2} + ... + θₚε_{t-q} + ε_t
  ```

**Full ARIMA(p,d,q) Equation**:
```
(1-φ₁L-φ₂L²-...-φₚLᵖ)(1-L)^d y_t = (1+θ₁L+θ₂L²+...+θₚL^q)ε_t
```

Where L is the lag operator: Ly_t = y_{t-1}

### 2.4 Seasonal ARIMA (SARIMA)

SARIMA(p,d,q)(P,D,Q)_s extends ARIMA with seasonal patterns:

- **P**: Seasonal AR order
- **D**: Seasonal differencing order  
- **Q**: Seasonal MA order
- **s**: Seasonal period (e.g., 24 for hourly data with daily seasonality)

**Example**: Temperature control system with daily cycles
- SARIMA(1,1,1)(1,1,1)₂₄ for hourly data with daily seasonality

## 3. Semiconductor Manufacturing Applications

### 3.1 Tool Drift Detection

**Use Case**: Monitoring chamber temperature drift in plasma etch tools.

**Characteristics**:
- Gradual trend due to component aging
- Daily temperature cycles from facility HVAC
- Step changes from maintenance events

**Modeling Approach**:
- SARIMA(2,1,1)(1,1,1)₂₄ for hourly temperature data
- Include maintenance flags as exogenous variables
- Set alert thresholds based on prediction intervals

### 3.2 SPC Signal Analysis

**Use Case**: Forecasting Statistical Process Control (SPC) metrics.

**Characteristics**:
- Mean reversion around control limits
- Autocorrelation from process memory
- Outliers from special causes

**Modeling Approach**:
- ARIMA(1,0,1) for stationary SPC signals
- Monitor forecast uncertainty to detect process changes
- Implement intervention analysis for known disturbances

### 3.3 Yield KPI Trends

**Use Case**: Predicting weekly yield metrics for capacity planning.

**Characteristics**:
- Long-term improvement trends
- Weekly operational patterns
- Product mix dependencies

**Modeling Approach**:
- SARIMA(1,1,2)(0,1,1)₅₂ for weekly data with annual seasonality
- Include product mix variables as exogenous regressors
- Generate prediction intervals for risk assessment

### 3.4 Preventive Maintenance Scheduling

**Use Case**: Forecasting equipment performance degradation.

**Characteristics**:
- Monotonic degradation between maintenance cycles
- Reset behavior after maintenance
- Varying operational intensity

**Modeling Approach**:
- Piecewise ARIMA models for maintenance cycles
- Cumulative operating hours as exogenous variable
- Threshold-based maintenance triggers

## 4. Model Selection and Diagnostics

### 4.1 Order Selection Methods

**Information Criteria**:
- **AIC** (Akaike): Balances fit and complexity
- **BIC** (Bayesian): Stronger penalty for complexity
- **HQIC** (Hannan-Quinn): Between AIC and BIC

**Automated Selection**:
- Grid search over (p,d,q) combinations
- Stepwise selection (pmdarima library)
- Cross-validation for final model comparison

### 4.2 Residual Diagnostics

**Ljung-Box Test**: Tests for residual autocorrelation
- H₀: Residuals are independent
- p-value > 0.05 indicates good model fit

**Normality Tests**:
- Jarque-Bera test for residual normality
- Q-Q plots for visual assessment

**Heteroscedasticity**:
- Breusch-Pagan test for constant variance
- Plot residuals vs. fitted values

### 4.3 Model Validation

**Time Series Cross-Validation**:
- Maintain temporal order in train/test splits
- Walk-forward validation for realistic assessment
- No shuffling to prevent data leakage

**Forecast Accuracy Metrics**:
- **MAE**: Mean Absolute Error (robust to outliers)
- **RMSE**: Root Mean Squared Error (penalizes large errors)
- **MAPE**: Mean Absolute Percentage Error (scale-independent)
- **PWS**: Prediction Within Specification (manufacturing-specific)

## 5. Feature Engineering for Time Series

### 5.1 Calendar Variables

**Temporal Features**:
- Hour of day, day of week, month of year
- Holiday indicators
- Shift patterns (day/night/weekend)

**Implementation**:
```python
df['hour'] = df.index.hour
df['dayofweek'] = df.index.dayofweek
df['is_weekend'] = df.index.dayofweek >= 5
```

### 5.2 Lag Features

**Process Memory**:
- Previous values: y_{t-1}, y_{t-2}, ...
- Moving averages: MA(n) for smoothing
- Exponentially weighted moving averages (EWMA)

**Maintenance Events**:
- Time since last maintenance
- Cumulative operating hours
- Binary maintenance indicators

### 5.3 External Regressors

**Environmental Variables**:
- Ambient temperature and humidity
- Facility power quality
- Clean room particle counts

**Production Context**:
- Product mix ratios
- Tool utilization rates
- Recipe complexity scores

## 6. Forecast Reconciliation

### 6.1 Engineering Constraints

**Physical Bounds**:
- Non-negativity constraints (temperatures, flows, yields)
- Maximum equipment capabilities
- Safety operating limits

**Implementation**:
```python
# Post-processing forecasts
forecasts = np.maximum(forecasts, 0)  # Non-negative
forecasts = np.minimum(forecasts, max_capacity)  # Capacity limit
```

### 6.2 Hierarchical Reconciliation

**Multi-level Forecasting**:
- Tool-level → Line-level → Fab-level
- Product-specific → Product family → Total
- Ensure consistency across hierarchy levels

## 7. Uncertainty Quantification

### 7.1 Prediction Intervals

**Parametric Intervals**:
- Assume normal forecast errors
- σ_forecast = √(σ²_ε + forecast_variance)
- 95% interval: forecast ± 1.96 × σ_forecast

**Bootstrap Intervals**:
- Resample residuals for non-parametric uncertainty
- Generate distribution of forecast scenarios
- More robust for non-normal errors

### 7.2 Risk-Based Decision Making

**Value at Risk (VaR)**:
- Probability of exceeding performance thresholds
- P(yield < 90%) = ?

**Expected Loss**:
- Combine forecast uncertainty with cost functions
- E[Loss] = ∫ Cost(error) × P(error) d(error)

## 8. Advanced Topics

### 8.1 State Space Models

**Kalman Filters**:
- Handle missing data and irregular sampling
- Real-time updating with new observations
- Separate trend, seasonal, and noise components

### 8.2 Regime-Switching Models

**Markov Switching**:
- Different model parameters for different states
- Useful for capturing maintenance cycles
- Automatic detection of regime changes

### 8.3 Multivariate Time Series

**Vector Autoregression (VAR)**:
- Model multiple related time series jointly
- Capture cross-correlations between tools
- Granger causality testing

## 9. Implementation Best Practices

### 9.1 Data Preparation

**Cleaning**:
- Handle missing values with forward-fill or interpolation
- Detect and handle outliers carefully
- Validate timestamp consistency

**Frequency Alignment**:
- Resample to consistent intervals
- Aggregate sub-period data appropriately
- Handle daylight saving time transitions

### 9.2 Model Development Workflow

1. **Exploratory Analysis**: Plot data, check stationarity, identify patterns
2. **Preprocessing**: Handle missing data, outliers, transformations
3. **Model Selection**: Compare multiple candidates with cross-validation
4. **Diagnostics**: Residual analysis, goodness-of-fit tests
5. **Validation**: Out-of-sample testing with proper temporal splits
6. **Deployment**: Real-time monitoring and model updating

### 9.3 Production Considerations

**Model Monitoring**:
- Track forecast accuracy over time
- Detect distribution drift in inputs
- Retrain based on performance degradation

**Computational Efficiency**:
- Use approximate methods for real-time applications
- Cache model parameters for fast scoring
- Implement incremental learning where possible

## 10. Common Pitfalls and Solutions

### 10.1 Data Leakage

**Problem**: Using future information to predict the past
**Solution**: Strict temporal ordering in all modeling steps

### 10.2 Over-Differencing

**Problem**: Removing too much information through differencing
**Solution**: Test minimal differencing needed for stationarity

### 10.3 Seasonal Misspecification

**Problem**: Wrong seasonal period or missing seasonality
**Solution**: Use ACF/PACF plots and seasonal decomposition

### 10.4 Structural Breaks

**Problem**: Model parameters change due to process modifications
**Solution**: Monitor residuals and implement adaptive updating

## 11. Case Study: Chamber Temperature Forecasting

### Problem Setup
Predict hourly chamber temperature 24 hours ahead for preventive maintenance scheduling.

### Data Characteristics
- 6 months of hourly temperature readings
- Daily HVAC cycles (±5°C variation)
- Gradual drift (+0.5°C per month)
- Maintenance resets every 2 weeks

### Modeling Steps

1. **Stationarity Analysis**:
   ```python
   adf_result = adfuller(temp_series)
   print(f"ADF p-value: {adf_result[1]:.4f}")
   # Result: p-value = 0.15 (non-stationary)
   ```

2. **Differencing**:
   ```python
   temp_diff = temp_series.diff().dropna()
   adf_diff = adfuller(temp_diff)
   print(f"Differenced ADF p-value: {adf_diff[1]:.4f}")
   # Result: p-value = 0.001 (stationary)
   ```

3. **Model Selection**:
   - Try SARIMA(p,1,q)(P,1,Q)₂₄
   - Grid search: p,q ∈ {0,1,2}, P,Q ∈ {0,1}
   - Best model: SARIMA(1,1,1)(1,1,1)₂₄

4. **Validation Results**:
   - MAE: 0.8°C
   - RMSE: 1.2°C  
   - 95% of predictions within ±2.5°C
   - Successfully detects drift for maintenance scheduling

## 12. References and Further Reading

**Books**:
- Box, G. E. P., Jenkins, G. M., & Reinsel, G. C. "Time Series Analysis: Forecasting and Control"
- Hyndman, R. J., & Athanasopoulos, G. "Forecasting: Principles and Practice"

**Software Libraries**:
- statsmodels: Comprehensive time series modeling
- pmdarima: Automated ARIMA model selection
- prophet: Additive model for business time series (optional)

**Semiconductor-Specific**:
- SEMI standards for equipment data collection
- NIST guidelines for measurement uncertainty
- Industry papers on predictive maintenance applications

---

**Next**: [5.1 Time Series Quick Reference](5.1-time-series-quick-ref.md)
