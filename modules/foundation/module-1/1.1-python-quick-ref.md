# Python Fundamentals Quick Reference

Essential Python concepts for semiconductor engineers

## Table of Contents

- [Data Types & Variables](#data-types--variables)
- [Control Structures](#control-structures)
- [Functions](#functions)
- [Object-Oriented Programming](#object-oriented-programming)
- [Error Handling](#error-handling)
- [File I/O](#file-io)
- [Libraries for Semiconductors](#libraries-for-semiconductors)
- [Common Patterns](#common-patterns)
- [Performance Tips](#performance-tips)

## Data Types & Variables

### Basic Types

```python
# Numbers
wafer_count = 25          # int
yield_rate = 0.85         # float
temperature = 23.5        # float
is_passing = True         # bool

# Strings
wafer_id = "W001"
lot_number = 'LOT_2024_001'
process_step = f"Step_{wafer_count}"  # f-string

# Lists (mutable)
temperatures = [23.5, 24.1, 23.8, 24.2]
wafer_ids = ["W001", "W002", "W003"]

# Tuples (immutable)
coordinates = (10, 15)    # x, y position
rgb_color = (255, 128, 0)

# Dictionaries
wafer_data = {
    "id": "W001",
    "yield": 0.85,
    "defects": 12
}

# Sets
unique_lots = {"LOT001", "LOT002", "LOT003"}
```

### Type Checking & Conversion

```python
# Check types
isinstance(yield_rate, float)  # True
type(wafer_count).__name__     # 'int'

# Convert types
str(wafer_count)     # "25"
int("123")           # 123
float("23.5")        # 23.5
list("ABC")          # ['A', 'B', 'C']
```

## Control Structures

### Conditionals

```python
# Basic if-else
if yield_rate > 0.9:
    status = "excellent"
elif yield_rate > 0.8:
    status = "good"
else:
    status = "needs_improvement"

# Inline conditional (ternary)
result = "pass" if yield_rate > 0.8 else "fail"

# Multiple conditions
if 0.8 <= yield_rate <= 0.95 and defect_count < 10:
    approval = "approved"
```

### Loops

```python
# For loops
for wafer_id in wafer_ids:
    print(f"Processing {wafer_id}")

# With enumerate (get index)
for i, wafer_id in enumerate(wafer_ids):
    print(f"Wafer {i}: {wafer_id}")

# Range loops
for step in range(1, 11):  # 1 to 10
    temperature = base_temp + step * 0.5

# While loops
temperature = 20.0
while temperature < target_temp:
    temperature += heat_rate
    time.sleep(0.1)

# List comprehensions
squared_temps = [t**2 for t in temperatures]
passing_wafers = [w for w in wafers if w.yield > 0.8]
```

## Functions

### Basic Functions

```python
def calculate_yield(good_die, total_die):
    """Calculate wafer yield percentage."""
    return (good_die / total_die) * 100

# With default arguments
def process_wafer(wafer_id, temperature=25.0, pressure=1.0):
    """Process wafer with default conditions."""
    return f"Processing {wafer_id} at {temperature}°C"

# Multiple return values
def analyze_wafer(data):
    """Return multiple analysis results."""
    yield_rate = calculate_yield(data)
    defect_count = count_defects(data)
    return yield_rate, defect_count

# Unpack multiple returns
yield_val, defects = analyze_wafer(wafer_data)
```

### Advanced Function Features

```python
# Lambda functions (inline)
sort_by_yield = lambda w: w['yield']
wafers.sort(key=sort_by_yield)

# *args and **kwargs
def log_measurement(*measurements, **metadata):
    """Accept any number of measurements and metadata."""
    print(f"Measurements: {measurements}")
    print(f"Metadata: {metadata}")

log_measurement(23.5, 24.1, lot="L001", operator="Alice")

# Decorators (function modifiers)
from functools import wraps
import time

def timing_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        print(f"{func.__name__} took {time.time() - start:.2f}s")
        return result
    return wrapper

@timing_decorator
def complex_analysis(data):
    # Your analysis code here
    pass
```

## Object-Oriented Programming

### Classes

```python
class Wafer:
    """Represents a semiconductor wafer."""

    # Class variable (shared by all instances)
    standard_diameter = 300  # mm

    def __init__(self, wafer_id, lot_number):
        """Initialize wafer object."""
        self.wafer_id = wafer_id
        self.lot_number = lot_number
        self.measurements = []
        self._processed = False  # Private variable

    def add_measurement(self, measurement):
        """Add a measurement to the wafer."""
        self.measurements.append(measurement)

    def calculate_yield(self):
        """Calculate current yield based on measurements."""
        if not self.measurements:
            return 0.0
        passing = sum(1 for m in self.measurements if m.is_passing)
        return (passing / len(self.measurements)) * 100

    @property
    def is_processed(self):
        """Property getter for processed status."""
        return self._processed

    @is_processed.setter
    def is_processed(self, value):
        """Property setter with validation."""
        if isinstance(value, bool):
            self._processed = value
        else:
            raise ValueError("is_processed must be boolean")

    def __str__(self):
        """String representation."""
        return f"Wafer({self.wafer_id}, Lot: {self.lot_number})"

    def __repr__(self):
        """Developer string representation."""
        return f"Wafer('{self.wafer_id}', '{self.lot_number}')"

# Usage
wafer = Wafer("W001", "LOT2024001")
wafer.add_measurement(measurement_data)
print(f"Yield: {wafer.calculate_yield():.2f}%")
```

### Inheritance

```python
class ProductionWafer(Wafer):
    """Production wafer with additional tracking."""

    def __init__(self, wafer_id, lot_number, fab_location):
        super().__init__(wafer_id, lot_number)
        self.fab_location = fab_location
        self.process_steps = []

    def add_process_step(self, step_name, timestamp):
        """Track process steps."""
        self.process_steps.append({
            'step': step_name,
            'timestamp': timestamp
        })

    def calculate_yield(self):
        """Override parent method with production logic."""
        base_yield = super().calculate_yield()
        # Apply production-specific adjustments
        return base_yield * 0.95  # Account for production variance

# Multiple inheritance
class QualityMixin:
    """Mixin for quality control features."""

    def quality_check(self):
        """Perform quality verification."""
        return self.calculate_yield() > 85.0

class QualityProductionWafer(ProductionWafer, QualityMixin):
    """Production wafer with quality controls."""
    pass
```

## Error Handling

### Basic Exception Handling

```python
# Try-except blocks
try:
    yield_rate = good_die / total_die
except ZeroDivisionError:
    print("Error: No die counted")
    yield_rate = 0.0
except Exception as e:
    print(f"Unexpected error: {e}")
    yield_rate = None

# Multiple exceptions
try:
    data = load_wafer_data(filename)
    process_data(data)
except FileNotFoundError:
    print("Data file not found")
except PermissionError:
    print("Permission denied accessing file")
except (ValueError, TypeError) as e:
    print(f"Data format error: {e}")
```

### Advanced Error Handling

```python
# Finally block (always executes)
try:
    file = open("wafer_data.txt", "r")
    data = file.read()
except IOError:
    print("File error occurred")
finally:
    if 'file' in locals():
        file.close()

# Context managers (automatic cleanup)
with open("wafer_data.txt", "r") as file:
    data = file.read()
    # File automatically closed

# Custom exceptions
class WaferProcessingError(Exception):
    """Custom exception for wafer processing issues."""

    def __init__(self, wafer_id, message):
        self.wafer_id = wafer_id
        self.message = message
        super().__init__(f"Wafer {wafer_id}: {message}")

# Raise custom exceptions
if temperature > max_temp:
    raise WaferProcessingError(wafer_id, "Temperature too high")
```

## File I/O

### Basic File Operations

```python
# Reading files
with open("data.txt", "r") as file:
    content = file.read()           # Read entire file
    lines = file.readlines()        # Read all lines as list
    first_line = file.readline()    # Read one line

# Writing files
with open("results.txt", "w") as file:
    file.write("Wafer analysis results\n")
    file.writelines(result_lines)

# Appending to files
with open("log.txt", "a") as file:
    file.write(f"Process completed: {timestamp}\n")
```

### Working with CSV and JSON

```python
import csv
import json

# CSV files
with open("wafer_data.csv", "r") as file:
    reader = csv.DictReader(file)
    for row in reader:
        wafer_id = row['wafer_id']
        yield_val = float(row['yield'])

# Writing CSV
data = [
    {'wafer_id': 'W001', 'yield': 0.85},
    {'wafer_id': 'W002', 'yield': 0.92}
]

with open("output.csv", "w", newline='') as file:
    writer = csv.DictWriter(file, fieldnames=['wafer_id', 'yield'])
    writer.writeheader()
    writer.writerows(data)

# JSON files
with open("config.json", "r") as file:
    config = json.load(file)

with open("results.json", "w") as file:
    json.dump(analysis_results, file, indent=2)
```

## Libraries for Semiconductors

### NumPy (Numerical Computing)

```python
import numpy as np

# Arrays
temps = np.array([23.5, 24.1, 23.8, 24.2])
wafer_map = np.zeros((50, 50))  # 50x50 wafer map
wafer_map[10:40, 10:40] = 1     # Mark good die

# Mathematical operations
mean_temp = np.mean(temps)
std_temp = np.std(temps)
normalized = (temps - mean_temp) / std_temp

# Array operations
good_die = np.sum(wafer_map)
yield_rate = good_die / wafer_map.size
center_region = wafer_map[20:30, 20:30]
```

### Pandas (Data Analysis)

```python
import pandas as pd

# DataFrames
df = pd.DataFrame({
    'wafer_id': ['W001', 'W002', 'W003'],
    'yield': [0.85, 0.92, 0.78],
    'defects': [12, 8, 18]
})

# Data operations
high_yield = df[df['yield'] > 0.8]
avg_yield = df['yield'].mean()
df['status'] = df['yield'].apply(lambda x: 'pass' if x > 0.8 else 'fail')

# Group operations
lot_stats = df.groupby('lot_number')['yield'].agg(['mean', 'std', 'count'])
```

### Matplotlib (Plotting)

```python
import matplotlib.pyplot as plt

# Basic plots
plt.figure(figsize=(10, 6))
plt.plot(time_points, temperatures, 'b-', label='Temperature')
plt.xlabel('Time (minutes)')
plt.ylabel('Temperature (°C)')
plt.title('Process Temperature Over Time')
plt.legend()
plt.grid(True)
plt.show()

# Wafer maps
plt.imshow(wafer_map, cmap='RdYlGn', aspect='equal')
plt.colorbar(label='Pass/Fail')
plt.title('Wafer Map Visualization')
```

## Common Patterns

### Data Processing Pipelines

```python
# Method chaining
result = (df
    .filter(lambda x: x['yield'] > 0.8)
    .groupby('lot')
    .agg({'yield': 'mean', 'defects': 'sum'})
    .sort_values('yield', ascending=False)
)

# Generator functions (memory efficient)
def process_wafers(wafer_files):
    """Generator to process wafers one at a time."""
    for filename in wafer_files:
        with open(filename) as f:
            data = load_wafer_data(f)
            yield analyze_wafer(data)

# Process large dataset efficiently
for result in process_wafers(all_wafer_files):
    save_result(result)
```

### Configuration Management

```python
from pathlib import Path
import configparser

# Using pathlib for file paths
data_dir = Path("data")
wafer_files = list(data_dir.glob("*.csv"))

# Configuration files
config = configparser.ConfigParser()
config.read('process_config.ini')

temperature_limit = config.getfloat('process', 'max_temperature')
pressure_setting = config.getfloat('process', 'pressure')
```

### Logging

```python
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('process.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# Use logging
logger.info(f"Processing wafer {wafer_id}")
logger.warning(f"Temperature {temp} approaching limit {limit}")
logger.error(f"Failed to process wafer {wafer_id}: {error}")
```

## Performance Tips

### List Comprehensions vs Loops

```python
# Faster: List comprehension
squared = [x**2 for x in numbers]

# Slower: Traditional loop
squared = []
for x in numbers:
    squared.append(x**2)

# Even faster for simple operations: NumPy
import numpy as np
numbers_np = np.array(numbers)
squared_np = numbers_np**2
```

### Efficient String Operations

```python
# Faster: Join method for string concatenation
lines = ["line1", "line2", "line3"]
result = "\n".join(lines)

# Slower: += operator in loop
result = ""
for line in lines:
    result += line + "\n"

# f-strings are fastest for formatting
message = f"Wafer {wafer_id} has yield {yield_rate:.2f}%"
```

### Memory Optimization

```python
# Use generators for large datasets
def read_large_file(filename):
    with open(filename) as f:
        for line in f:
            yield process_line(line)

# Use __slots__ to reduce memory in classes
class EfficientWafer:
    __slots__ = ['wafer_id', 'yield_rate', 'defect_count']

    def __init__(self, wafer_id, yield_rate, defect_count):
        self.wafer_id = wafer_id
        self.yield_rate = yield_rate
        self.defect_count = defect_count
```

### Timing and Profiling

```python
import time
from functools import wraps

# Simple timing
start_time = time.time()
process_wafers()
elapsed = time.time() - start_time
print(f"Processing took {elapsed:.2f} seconds")

# Timing decorator
def time_it(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        elapsed = time.time() - start
        print(f"{func.__name__} took {elapsed:.2f}s")
        return result
    return wrapper

@time_it
def analyze_wafer_batch(wafers):
    # Analysis code here
    pass
```

## Quick Commands Reference

### Interactive Python (REPL)

```bash
python          # Start Python interpreter
python -i       # Interactive mode after script
python -c "print('Hello')"  # Execute command
pip install package_name    # Install package
pip list        # List installed packages
```

### Common Debugging

```python
# Print debugging
print(f"Debug: variable = {variable}")

# Breakpoint (Python 3.7+)
breakpoint()    # Starts debugger

# Assert statements
assert yield_rate >= 0, "Yield cannot be negative"
assert wafer_id, "Wafer ID cannot be empty"

# Inspect object
dir(object)     # List attributes
help(function)  # Get help
type(variable)  # Get type
```

### Virtual Environments

```bash
# Create virtual environment
python -m venv semiconductor_env

# Activate (Windows)
semiconductor_env\Scripts\activate

# Activate (Linux/Mac)
source semiconductor_env/bin/activate

# Deactivate
deactivate

# Install from requirements
pip install -r requirements.txt

# Create requirements file
pip freeze > requirements.txt
```

---

## Key Takeaways

1. **Use meaningful variable names** - `wafer_yield` not `y`
2. **Follow PEP 8** - Python style guidelines
3. **Write docstrings** - Document your functions
4. **Handle errors gracefully** - Use try-except blocks
5. **Use appropriate data structures** - Lists for sequences, dicts for mappings
6. **Leverage libraries** - NumPy for numbers, Pandas for data
7. **Profile before optimizing** - Measure first, optimize second
8. **Write tests** - Verify your code works correctly

*This quick reference covers the essential Python concepts needed for semiconductor data analysis and automation.*
