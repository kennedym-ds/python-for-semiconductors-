# Module 7.1: Advanced Defect Detection Quick Reference

## CLI Commands

### Train a Model
```bash
# Classical detection (no training required)
python 7.1-advanced-defect-detection-pipeline.py train \
  --backend classical \
  --dataset synthetic \
  --n-images 50 \
  --save classical_model.joblib

# YOLO detection (requires ultralytics)
python 7.1-advanced-defect-detection-pipeline.py train \
  --backend yolo \
  --dataset synthetic \
  --n-images 100 \
  --epochs 10 \
  --save yolo_model.joblib

# Faster R-CNN detection (requires torchvision)
python 7.1-advanced-defect-detection-pipeline.py train \
  --backend fasterrcnn \
  --dataset synthetic \
  --n-images 100 \
  --epochs 10 \
  --save fasterrcnn_model.joblib
```

### Evaluate a Model
```bash
python 7.1-advanced-defect-detection-pipeline.py evaluate \
  --model-path model.joblib \
  --dataset synthetic \
  --n-images 20 \
  --iou-threshold 0.5
```

### Make Predictions
```bash
# Predict on specific image
python 7.1-advanced-defect-detection-pipeline.py predict \
  --model-path model.joblib \
  --image-path wafer_image.jpg

# Predict on synthetic data
python 7.1-advanced-defect-detection-pipeline.py predict \
  --model-path model.joblib \
  --dataset synthetic
```

## Backend Comparison

| Backend | Speed | Accuracy | CPU-Friendly | Training Required | Dependencies |
|---------|-------|----------|--------------|-------------------|--------------|
| Classical | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ✅ | ❌ | OpenCV only |
| YOLO | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ✅ | ultralytics |
| Faster R-CNN | ⭐⭐ | ⭐⭐⭐⭐⭐ | ❌ | ✅ | torchvision |

## Hyperparameters

### Classical Backend
```bash
--blur-kernel 5         # Gaussian blur kernel size
--threshold-value 50    # Edge detection threshold
```

### YOLO Backend
```bash
--epochs 10            # Training epochs
# Model automatically handles other hyperparameters
```

### Faster R-CNN Backend
```bash
--epochs 10            # Training epochs  
# Uses pre-trained ResNet50 backbone
```

## Performance Tuning

### For Speed (Real-time Processing)
1. **Use Classical Backend**: Fastest, CPU-only
2. **Reduce Image Size**: Smaller input images
3. **Lower Confidence Threshold**: Fewer detections to process
4. **Optimize NMS**: Higher NMS threshold (more suppression)

### For Accuracy
1. **Use Faster R-CNN**: Highest accuracy
2. **Increase Training Data**: More synthetic images
3. **Lower IoU Threshold**: More lenient matching
4. **Ensemble Methods**: Combine multiple models

### For Production Deployment
1. **Start with Classical**: Establish baseline
2. **Gradual Upgrade**: Add deep learning as needed
3. **A/B Testing**: Compare backends on real data
4. **Monitor Performance**: Track metrics over time

## Defect Types

| Type | Characteristics | Classical Detection | Deep Learning Advantage |
|------|----------------|-------------------|------------------------|
| Scratch | Linear, variable length | Line detection, Hough transform | Orientation invariance |
| Particle | Circular/irregular blobs | Blob detection, contours | Shape robustness |
| Crack | Branching, thin lines | Edge detection + morphology | Pattern learning |

## Key Metrics

### Detection Metrics
- **Precision**: TP / (TP + FP) - Accuracy of detections
- **Recall**: TP / (TP + FN) - Coverage of actual defects  
- **F1-Score**: Harmonic mean of precision and recall
- **mAP@0.5**: Mean Average Precision at IoU threshold 0.5

### Manufacturing Metrics
- **PWS**: Prediction Within Spec percentage
- **Estimated Loss**: Economic impact of detection errors
- **True/False Positives/Negatives**: Confusion matrix components

## IoU Thresholds

| Threshold | Use Case | Strictness |
|-----------|----------|------------|
| 0.3 | Loose matching | Low |
| 0.5 | Standard detection | Medium |
| 0.7 | Precise localization | High |
| 0.9 | Extremely precise | Very High |

## Cost Parameters

```python
# Default cost structure
defect_cost_per_miss = 1000.0   # Cost of missing a defect (USD)
false_alarm_cost = 100.0        # Cost of false alarm (USD)
```

Adjust based on:
- **Defect Severity**: Critical defects have higher miss cost
- **Production Volume**: High volume = higher false alarm cost
- **Rework Cost**: Difficulty of fixing detected issues

## Fallback Strategy

The pipeline automatically falls back based on available dependencies:

```
YOLO (ultralytics) → Faster R-CNN (torchvision) → Classical (OpenCV)
```

### Checking Available Backends
```python
python -c "
import warnings
warnings.filterwarnings('ignore')

try:
    import ultralytics
    print('✓ YOLO (ultralytics) available')
except ImportError:
    print('✗ YOLO (ultralytics) not available')

try:
    import torch, torchvision
    print('✓ Faster R-CNN (torchvision) available')
except ImportError:
    print('✗ Faster R-CNN (torchvision) not available')

print('✓ Classical (OpenCV) always available')
"
```

## Synthetic Data Generation

### Parameters
```python
n_images = 50                    # Number of images to generate
image_size = (416, 416)         # (height, width) in pixels
n_defects_range = (1, 5)        # Min/max defects per image
seed = 42                       # For reproducibility
```

### Defect Properties
- **Scratches**: Length 20-80px, random orientation
- **Particles**: Radius 3-15px, circular shape
- **Cracks**: 3-8 connected line segments

## Common Issues and Solutions

### Issue: "ultralytics not available"
**Solution**: Install with `pip install ultralytics` or use classical backend

### Issue: "torchvision not available"  
**Solution**: Install with `pip install torch torchvision` or use classical backend

### Issue: Low detection accuracy
**Solutions**:
- Increase training data (`--n-images`)
- Lower IoU threshold (`--iou-threshold 0.3`)
- Tune classical parameters (`--blur-kernel`, `--threshold-value`)

### Issue: Too many false positives
**Solutions**:
- Increase confidence threshold in model
- Tune NMS parameters
- Use higher IoU threshold for evaluation

### Issue: Slow inference
**Solutions**:
- Use classical backend
- Reduce image size
- Optimize for CPU deployment

## Example Workflows

### Quick Start (Classical)
```bash
# Train
python 7.1-advanced-defect-detection-pipeline.py train --backend classical --save model.joblib

# Test
python 7.1-advanced-defect-detection-pipeline.py evaluate --model-path model.joblib --dataset synthetic
```

### Production Pipeline
```bash
# 1. Baseline with classical
python 7.1-advanced-defect-detection-pipeline.py train --backend classical --save baseline.joblib

# 2. Deep learning comparison
python 7.1-advanced-defect-detection-pipeline.py train --backend yolo --epochs 20 --save yolo.joblib

# 3. Evaluate both
python 7.1-advanced-defect-detection-pipeline.py evaluate --model-path baseline.joblib --dataset synthetic > baseline_results.json
python 7.1-advanced-defect-detection-pipeline.py evaluate --model-path yolo.joblib --dataset synthetic > yolo_results.json
```

### Hyperparameter Tuning
```bash
# Classical parameter sweep
for kernel in 3 5 7; do
  for threshold in 30 50 70; do
    python 7.1-advanced-defect-detection-pipeline.py train \
      --backend classical \
      --blur-kernel $kernel \
      --threshold-value $threshold \
      --save model_k${kernel}_t${threshold}.joblib
  done
done
```

## Python API Usage

```python
from pathlib import Path
from advanced_defect_detection_pipeline import (
    AdvancedDefectDetectionPipeline,
    generate_synthetic_wafer_defects
)

# Generate data
images, annotations = generate_synthetic_wafer_defects(n_images=10)

# Train model
pipeline = AdvancedDefectDetectionPipeline(backend='classical')
pipeline.fit(images, annotations)

# Evaluate
metrics = pipeline.evaluate(images, annotations)
print(f"mAP: {metrics['map_50']:.3f}")
print(f"PWS: {metrics['pws_percent']:.1f}%")

# Save/load
pipeline.save(Path('model.joblib'))
loaded_pipeline = AdvancedDefectDetectionPipeline.load(Path('model.joblib'))
```

## Resources

- **Fundamentals**: See `7.1-advanced-defect-detection-fundamentals.md`
- **Interactive Tutorial**: Run `7.1-advanced-defect-detection.ipynb`
- **Full Pipeline**: `7.1-advanced-defect-detection-pipeline.py`
- **Tests**: Run `python test_advanced_detection_pipeline.py`